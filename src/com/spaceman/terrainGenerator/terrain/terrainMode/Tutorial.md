# Custom TerrainMode tutorial*Last updated: 1.15****This is a tutorial created to make your own TerrainMode for the plugin TerrainGenerator.#Creation:First I'll tell you about the differed TerrainMode data types, there are 3 you can use: DataMode, ArrayMode and MapMode.These are not necessary but should help you. The Terrain Commands won't work if they are not any of these 3 types. YOu have to create your own.A Data TerrainMode is a TerrainMode that only uses 1 object to function, an Array TerrainMode stores an array with your chosen type, and a Map TerrainMode used a LinkedHashMap.For this tutorial I'm going to create Data TerrainMode that does the same as the Top TerrainMode (this already exist in the TerrainGenerator plugin).First you'll create your class (I'll named it ExampleMode).This class extends your chosen data type.```javapublic class ExampleMode extends DataMode<TerrainBlockData> {}```Your IDE should give you an error like this: "Class ExampleMode must either be declared abstract or implement abstract method 'setData(LinkedList<String>, Player)' in 'DataMode'"You want to implement all given methods.Its best to use the class TerrainBlockData if you want blocks to edit.TerrainBlockData stores the material data, block direction data and if its waterlogged.Its also made to work with the bukkit yaml files (serialization and deserialization)Then your class should look like this:```javaimport com.spaceman.terrainGenerator.terrain.TerrainBlockData;import com.spaceman.terrainGenerator.terrain.TerrainGenData;import com.spaceman.terrainGenerator.terrain.generators.TerrainGenerator;import com.spaceman.terrainGenerator.terrain.generators.WorldGenerator;import com.spaceman.terrainGenerator.terrain.terrainMode.DataMode;import com.spaceman.terrainGenerator.terrain.terrainMode.TerrainMode;import org.bukkit.configuration.ConfigurationSection;import org.bukkit.entity.Player;import java.util.HashMap;import java.util.LinkedList;public class ExampleMode extends DataMode<TerrainBlockData> {       @Override    public void setData(LinkedList<String> data, Player player) {       }       @Override    public String getModeName() {        return null;    }       @Override    public boolean isFinalMode() {        return false;    }       @Override    public String getModeDescription() {        return null;    }       @Override    public void saveMode(ConfigurationSection section) {       }       @Override    public TerrainMode loadMode(ConfigurationSection section) {        return null;    }       @Override    public void useMode(int x, int z, HashMap<String, HashMap<String, TerrainGenerator.GenData>> genStorage, TerrainGenerator.LocData locData, TerrainGenData data, String savePath, HashMap<String, Object> genModeData, WorldGenerator.TerrainChunkData chunkData) {       }}```###setDataThe setData method is used to set the data for the TerrainMode given from the commands:  //terrain mode edit <name> <TerrainMode name> set <data...>  //terrain mode add <name> <name> [data...]  //terrain mode set <name> <TerrainMode name> <number> [data...]  For more information see the DataMode.java, ArrayMode.java or the MapMode.java  You can do 2 things in your setData method:  1: create your own function;  2: use the TerrainUtils method.  The LinkedList<String> is the list with the arguments form the command (only the data... arguments)  And the Player is the player who executed the command, this can be used for feedback###getModeName  This is used to get the TerrainMode its name, I'll use now "ExampleMode";###isFinalMode  A final TerrainMode is used when the generation of the terrain is done, so it can use the terrain around it and the terrain of the TerrainGenerators in the gens list. When it's not a final mode the TerrainMode is used after the y is done of the TerrainGenerator where this TerrainMode is in is done. a NOT final TerrainMode is mostly used to change blocks within the owning TerrainGenerator like Top, TopR or Layers.###getModeDescription  In here you can return the description of the TerrainMode, It's a String that is used for'/terrain mode description <TerrainMode name>' and '/terrain mode list [name]'###saveMode  This is used to save the TerrainMode. You can (just like setData) create your own function or look in TerrainUtils. For this example I'll create my own to show you how it works.###loadMode  This us used to load the TerrainMode. You can (just like setData) create your own function or look in TerrainUtils. For this example I'll create my own to show you how it works.###useMode  This is the method that is the function that edits the terrain.  Because the useMode is used for terrain generation and world generation there are some thinks you should look at  'int x' is the real x coordinate,  'int z' is the real z coordinate,  'HashMap<String, HashMap<String, TerrainGenerator.GenData>> genStorage' is the generation storage  'TerrainGenerator.LocData locData' is the start position of the generation  'TerrainGenData data' is the owning TerrainGenerator  'String savePath' is the savePath to store your TerrainMode data in for later use in the generation process  'HashMap<String, Object> genModeData' is the place to store your TerrainMode data in for later use in the generation process  'WorldGenerator.TerrainChunkData chunkData' chunk data for world generation  lets fill in my class:```javaimport com.spaceman.terrainGenerator.terrain.TerrainBlockData;import com.spaceman.terrainGenerator.terrain.TerrainGenData;import com.spaceman.terrainGenerator.terrain.TerrainUtils;import com.spaceman.terrainGenerator.terrain.generators.TerrainGenerator;import com.spaceman.terrainGenerator.terrain.generators.WorldGenerator;import com.spaceman.terrainGenerator.terrain.terrainMode.DataMode;import com.spaceman.terrainGenerator.terrain.terrainMode.TerrainMode;import com.sun.istack.internal.NotNull;import org.bukkit.Location;import org.bukkit.Material;import org.bukkit.configuration.ConfigurationSection;import org.bukkit.entity.Player;import java.util.HashMap;import java.util.LinkedList;import static com.spaceman.terrainGenerator.terrain.TerrainCore.setType;import static com.spaceman.terrainGenerator.terrain.generators.TerrainGenerator.GenData.*;public class ExampleMode extends DataMode<TerrainBlockData> {       @Override    public void setData(LinkedList<String> data, Player player) {        TerrainUtils.setDataTerrainBlockData(data, player, this);    }       @Override    public String getModeName() {        return "ExampleMode";    }       @Override    public boolean isFinalMode() {        return false;    }       @Override    public String getModeDescription() {        return "The example TerrainMode";    }       @Override    public void saveMode(ConfigurationSection section) {        if (this.getModeData() != null) {            section.set("data", this.getModeData());        }    }       @Override    public TerrainMode loadMode(ConfigurationSection section) {        TerrainBlockData data = (TerrainBlockData) section.get("data");        this.setModeData(data);        return this;    }       @Override    public void useMode(int x, int z, HashMap<String, HashMap<String, TerrainGenerator.GenData>> genStorage,                        TerrainGenerator.LocData locData, TerrainGenData data, String savePath, HashMap<String, Object> genModeData, WorldGenerator.TerrainChunkData chunkData) {           //check is material type is not Material.STRUCTURE_VOID        //I use STRUCTURE_VOID the same as Minecraft does, a material that is ignored        if (!getModeData().getMaterial().equals(Material.STRUCTURE_VOID)) {                       //get the generation data for your TerrainGenerator            TerrainGenerator.GenData genData = getGenData(x, z, data.getName() + savePath, genStorage);            //get the highest block of the total terrain (including all generated TerrainGenerators), this can change after the next generator generated above it            int highest = getHighest(x, z, genStorage);                       //check if your are the top one, and if above 0            if (genData.getHeightGen() == highest && genData.getHeightGen() > 0 ||                    //get all air pockets and check if the next block above yours is not generated                    getAirPockets(x, z, genStorage, genData.getStartGen(), highest).contains(genData.getHeightGen() + 1)) {                               //check if the bottom is not above the top layer, if this is true (bottom > top) there won't be any generation                if (genData.getStartGen() < genData.getHeightGen()) {                    int y = genData.getHeightGen(); //get the top layer (to change)                                   if (chunkData != null) { //check if its a world generation, of terrain generation                        //change the block to the TerrainMode its block in that chunk                        chunkData.setBlock(y, getModeData());                    } else {                        //change the block to the TerrainMode its block in the world                        setType(new Location(locData.getWorld(), x, y, z).getBlock(), getModeData());                    }                }            }        }    }}```There are some extra function you can implement:  -tabListSet  -tabListCreate  -dataAsString  -dataAsStringWithHover  *If its a DataMode:*  -getInsertion  *If its an ArrayMode:*  -[getInsertion](https://github.com/skylinerw/guides/blob/master/java/text%20component.md#listeners-insertion)  -tabListAdd  -tabListRemove  *If its a MapMode:*  -getInsertion  -tabListAdd  -tabListRemove  The tab lists are for the commandsLets implement these as well:```java        @Override    public String getInsertion() {        return "m=" + getModeData().getMaterial().name() +                ",d=" + getModeData().getBlockFace().name() +                ",w=" + getModeData().isWaterLogged();    }       @Override    public Collection<String> tabListCreate(String[] args, Player player) {        return TerrainUtils.tabListCreateAndSetTerrainBlockData(args);    }       @Override    public Collection<String> tabListSet(String[] args, Player player) {        return TerrainUtils.tabListCreateAndSetTerrainBlockData(args);    }       @Override    public Message dataAsString() {        return super.dataAsString(); //the default is fine for this    }       @Override    public Message dataAsStringWithHover() {        return super.dataAsStringWithHover(); //the default is fine for this    }```Now you only have to register it#Registration:In the class TerrainMode there is a function called 'registerModes(ModeCreator... modes)', this registers your TerrainMode.Example code (its not everything, but it shows you the important stuff):```javaimport org.bukkit.plugin.java.JavaPlugin;import static com.spaceman.terrainGenerator.terrain.terrainMode.TerrainMode.registerModes;class yourMainClass extends JavaPlugin {    @Override    onEnable() {        registerModes(ExampleMode::new);    }}```